import streamlit as st
import torch
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import time
import json
import os
import sys
sys.path.append('.')
from importlib import import_module
gray_scott_module = import_module('2d_gray_scott_model')
GrayScott2DPINN = gray_scott_module.GrayScott2DPINN

# Set page config
st.set_page_config(
    page_title="2D Gray-Scott PINN Visualizer",
    page_icon="üß¨",
    layout="wide"
)

@st.cache_resource
def load_model():
    """Load the trained 2D Gray-Scott PINN model"""
    model_file = '2d_gray_scott_model.pth'
    metadata_file = '2d_gray_scott_model_metadata.json'
    
    if not os.path.exists(model_file):
        st.error(f"""
        ‚ùå **No trained 2D model found!** 
        
        Please train the 2D model first by running:
        ```bash
        python 2d_gray_scott_model.py
        ```
        """)
        return GrayScott2DPINN(), False, {}
    
    try:
        # Load metadata
        metadata = {}
        if os.path.exists(metadata_file):
            with open(metadata_file, 'r') as f:
                metadata = json.load(f)
        
        # Create model with correct architecture
        model = GrayScott2DPINN(
            hidden_size=metadata.get('hidden_size', 20),
            num_layers=metadata.get('num_layers', 4)
        )
        
        # Load model weights
        model.load_state_dict(torch.load(model_file, map_location='cpu', weights_only=True))
        model.eval()
        
        st.success(f"‚úÖ Loaded 2D Gray-Scott PINN model")
        return model, True, metadata
        
    except Exception as e:
        st.error(f"‚ùå Failed to load model: {str(e)}")
        return GrayScott2DPINN(), False, {}

def generate_grid(resolution=101):
    """Generate spatial grid for visualization"""
    x = np.linspace(0, 1, resolution)
    y = np.linspace(0, 1, resolution)
    X, Y = np.meshgrid(x, y, indexing='ij')
    return X.flatten(), Y.flatten()

def predict_pattern(model, x, y, t):
    """Predict u and v values using the trained 2D PINN"""
    with torch.no_grad():
        x_tensor = torch.tensor(x, dtype=torch.float32).unsqueeze(1)
        y_tensor = torch.tensor(y, dtype=torch.float32).unsqueeze(1)
        t_tensor = torch.full_like(x_tensor, t)
        
        u, v = model(x_tensor, y_tensor, t_tensor)
        return u.numpy().flatten(), v.numpy().flatten()

def create_custom_colormap():
    """Create a custom colormap for Gray-Scott visualization"""
    # Colors optimized for reaction-diffusion patterns
    colors = ['#000033', '#000080', '#0040FF', '#00FFFF', '#40FF40', '#FFFF00', '#FF8000', '#FF0000', '#800000']
    return LinearSegmentedColormap.from_list('gray_scott', colors)

def create_pattern_info(metadata):
    """Create information display about the pattern parameters"""
    if metadata:
        F = metadata.get('F', 0.030)
        K = metadata.get('K', 0.060)
        Du = metadata.get('Du', 2e-5)
        Dv = metadata.get('Dv', 1e-5)
        
        return f"""
        **Pattern Parameters:**
        - Feed Rate (F): {F:.3f}
        - Kill Rate (K): {K:.3f}  
        - Diffusion u (Du): {Du:.2e}
        - Diffusion v (Dv): {Dv:.2e}
        
        **Expected Pattern:** Spots and Stripes
        """
    return "**Pattern Type:** Gray-Scott Reaction-Diffusion"

def main():
    st.title("üß¨ 2D Gray-Scott PINN Pattern Visualizer")
    
    st.markdown("""
    This app visualizes Turing patterns generated by a Physics-Informed Neural Network (PINN) 
    trained on the 2D Gray-Scott reaction-diffusion system.
    """)
    
    # Load model
    model, model_loaded, metadata = load_model()
    
    if not model_loaded:
        st.stop()
    
    # Sidebar controls
    st.sidebar.header("üéÆ Controls")
    
    # Display pattern information
    st.sidebar.markdown(create_pattern_info(metadata))
    
    st.sidebar.markdown("---")
    
    # Time control
    st.sidebar.subheader("‚è∞ Time Control")
    
    # Animation toggle
    animate = st.sidebar.checkbox("üé¨ Enable Animation", value=False)
    
    if animate:
        # Animation controls
        st.sidebar.subheader("üéûÔ∏è Animation Settings")
        
        animation_speed = st.sidebar.slider(
            "Animation Speed", 
            min_value=0.1, 
            max_value=3.0, 
            value=1.0, 
            step=0.1,
            help="Controls how fast time progresses in the animation"
        )
        
        time_range = st.sidebar.slider(
            "Time Range", 
            min_value=0.0, 
            max_value=5000.0, 
            value=(0.0, 2000.0), 
            step=100.0,
            help="Start and end time for animation"
        )
        
        # Auto-loop option
        auto_loop = st.sidebar.checkbox("üîÑ Loop Animation", value=True)
    else:
        # Static time control
        t = st.sidebar.slider(
            "Time", 
            min_value=0.0, 
            max_value=5000.0, 
            value=1000.0, 
            step=50.0,
            help="Select specific time to visualize"
        )
    
    # Display options
    st.sidebar.markdown("---")
    st.sidebar.subheader("üé® Display Options")
    
    resolution = st.sidebar.selectbox(
        "Grid Resolution", 
        options=[51, 101, 151], 
        index=1,
        help="Higher resolution = more detail but slower"
    )
    
    show_colorbar = st.sidebar.checkbox("Show Color Scale", value=True)
    
    # Main visualization area
    if animate:
        st.subheader(f"üé¨ Animated Pattern Evolution (Speed: {animation_speed}x)")
    else:
        st.subheader(f"üì∏ Pattern at t = {t:.0f}")
    
    col1, col2 = st.columns(2)
    
    # Generate grid
    x_grid, y_grid = generate_grid(resolution)
    
    # Create placeholders for plots
    with col1:
        st.markdown("### üî¥ Species U (Activator)")
        plot_placeholder_u = st.empty()
        if not animate:
            info_placeholder_u = st.empty()
    
    with col2:
        st.markdown("### üîµ Species V (Inhibitor)")
        plot_placeholder_v = st.empty()
        if not animate:
            info_placeholder_v = st.empty()
    
    # Create custom colormap
    cmap = create_custom_colormap()
    
    # Progress bar for animation
    if animate:
        progress_bar = st.progress(0)
        status_text = st.empty()
    
    # Animation loop
    if animate:
        time_start, time_end = time_range
        time_points = np.linspace(time_start, time_end, 100)
        
        frame = 0
        while True:
            for i, current_time in enumerate(time_points):
                # Update progress
                progress = i / len(time_points)
                progress_bar.progress(progress)
                status_text.text(f"Time: {current_time:.0f} | Frame: {frame + 1}")
                
                # Predict patterns
                try:
                    u_pred, v_pred = predict_pattern(model, x_grid, y_grid, current_time)
                    
                    # Reshape for plotting
                    u_2d = u_pred.reshape(resolution, resolution)
                    v_2d = v_pred.reshape(resolution, resolution)
                    
                    # Plot U
                    fig_u, ax_u = plt.subplots(figsize=(6, 6))
                    im_u = ax_u.imshow(u_2d, cmap=cmap, origin='lower', extent=[0, 1, 0, 1])
                    ax_u.set_title(f'Species U at t={current_time:.0f}')
                    ax_u.set_xlabel('x')
                    ax_u.set_ylabel('y')
                    if show_colorbar:
                        plt.colorbar(im_u, ax=ax_u, shrink=0.8)
                    
                    # Plot V
                    fig_v, ax_v = plt.subplots(figsize=(6, 6))
                    im_v = ax_v.imshow(v_2d, cmap=cmap, origin='lower', extent=[0, 1, 0, 1])
                    ax_v.set_title(f'Species V at t={current_time:.0f}')
                    ax_v.set_xlabel('x')
                    ax_v.set_ylabel('y')
                    if show_colorbar:
                        plt.colorbar(im_v, ax=ax_v, shrink=0.8)
                    
                    # Update plots
                    with col1:
                        plot_placeholder_u.pyplot(fig_u)
                    with col2:
                        plot_placeholder_v.pyplot(fig_v)
                    
                    plt.close(fig_u)
                    plt.close(fig_v)
                    
                    # Control animation speed
                    time.sleep(0.1 / animation_speed)
                    
                except Exception as e:
                    st.error(f"Error during animation: {str(e)}")
                    break
                
                frame += 1
            
            # Break if not looping
            if not auto_loop:
                break
                
            # Reset progress for next loop
            progress_bar.progress(0)
    
    else:
        # Static visualization
        try:
            u_pred, v_pred = predict_pattern(model, x_grid, y_grid, t)
            
            # Reshape for plotting
            u_2d = u_pred.reshape(resolution, resolution)
            v_2d = v_pred.reshape(resolution, resolution)
            
            # Calculate statistics
            u_stats = f"Min: {u_pred.min():.3f}, Max: {u_pred.max():.3f}, Mean: {u_pred.mean():.3f}"
            v_stats = f"Min: {v_pred.min():.3f}, Max: {v_pred.max():.3f}, Mean: {v_pred.mean():.3f}"
            
            # Plot U
            fig_u, ax_u = plt.subplots(figsize=(6, 6))
            im_u = ax_u.imshow(u_2d, cmap=cmap, origin='lower', extent=[0, 1, 0, 1])
            ax_u.set_title(f'Species U at t={t:.0f}')
            ax_u.set_xlabel('x')
            ax_u.set_ylabel('y')
            if show_colorbar:
                plt.colorbar(im_u, ax=ax_u, shrink=0.8)
            
            # Plot V
            fig_v, ax_v = plt.subplots(figsize=(6, 6))
            im_v = ax_v.imshow(v_2d, cmap=cmap, origin='lower', extent=[0, 1, 0, 1])
            ax_v.set_title(f'Species V at t={t:.0f}')
            ax_v.set_xlabel('x')
            ax_v.set_ylabel('y')
            if show_colorbar:
                plt.colorbar(im_v, ax=ax_v, shrink=0.8)
            
            # Display plots
            with col1:
                plot_placeholder_u.pyplot(fig_u)
                info_placeholder_u.info(f"üìä **Statistics:** {u_stats}")
            with col2:
                plot_placeholder_v.pyplot(fig_v)
                info_placeholder_v.info(f"üìä **Statistics:** {v_stats}")
            
            plt.close(fig_u)
            plt.close(fig_v)
            
        except Exception as e:
            st.error(f"Error generating visualization: {str(e)}")
    
    # Footer with model information
    st.markdown("---")
    if metadata:
        training_info = metadata.get('training_info', {})
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Final Epoch", training_info.get('final_epoch', 'N/A'))
        with col2:
            st.metric("Best Loss", f"{training_info.get('best_loss', 0):.2e}")
        with col3:
            st.metric("Grid Resolution", f"{resolution}√ó{resolution}")

if __name__ == "__main__":
    main() 